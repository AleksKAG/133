diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..723ef36
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+.idea
\ No newline at end of file
diff --git a/main.go b/main.go
index 90c9205..dbb1aa8 100644
--- a/main.go
+++ b/main.go
@@ -21,8 +21,15 @@ type Tasks struct {
 	Tasks []Task `json:"tasks"`
 }
 
-var response struct {
-	Error string `json:"error,omitempty"`
+func (t *Task) IsValid() (bool, string) {
+	if len(t.Title) == 0 {
+		return false, "no title"
+	}
+
+	if len(t.Date) == 0 {
+		return false, "no date"
+	}
+
 }
 
 func CreateDB(DBFile string) {
diff --git a/tasksHandlers.go b/tasksHandlers.go
index c2fdad5..8c93abb 100644
--- a/tasksHandlers.go
+++ b/tasksHandlers.go
@@ -6,219 +6,236 @@ import (
 	"encoding/json"
 	"errors"
 	"fmt"
+	"io"
 	"net/http"
+	"strconv"
 	"time"
 )
 
-func checkInputJSON(res http.ResponseWriter, task *Task) error {
-	var err error
-	res.Header().Set("Content-Type", "application/json; charset=UTF-8")
-	if task.Title == "" {
-		err := errors.New("Title error")
+type ErrResponse struct {
+	Error        bool   `json:"error"`
+	ErrorMessage string `json:"error_message"`
+}
+
+func sendJson(rw http.ResponseWriter, status int, r any) error {
+	b, err := json.Marshal(r)
+	if err != nil {
+		return err
+	}
+	rw.Header().Set("Content-Type", "application/json") // set content-type so our clients know how to read our response
+	rw.WriteHeader(status)                              // write our status header with the proper http code
+	// write the marshalled json into the response.
+	// as per documentation, this is a final call in handling requests and will finish the handling process.
+	_, err = rw.Write(b)
+	return err
+}
+
+func getTask(id int) (*Task, error) {
+	db, err := sql.Open("sqlite3", DBFile)
+	defer db.Close()
+	if err != nil {
+		return nil, err
+	}
+
+	query := "SELECT * FROM scheduler WHERE id=?"
+	row := db.QueryRow(query, id)
+
+	var task *Task
+	switch err := row.Scan(task); err {
+	case sql.ErrNoRows:
+		return nil, nil // no task, but no error too
+	case nil:
+		return task, nil // no error, return task
+	default:
+		return nil, err // any other error, return it as is
+	}
+}
+
+func deleteTask() {
+	id := req.FormValue("id")
+	if id == "" {
+		err := errors.New("Не укаазан ID задачи")
 		response.Error = err.Error()
 		json.NewEncoder(res).Encode(response)
-		return err
+		return
 	}
 
-	date := time.Now()
+	db, err := sql.Open("sqlite3", DBFile)
+	defer db.Close()
+	if err != nil {
+		return
+	}
+
+	query := "DELETE FROM scheduler WHERE id=?"
+	_, err = db.Exec(query, id)
+
+	if err != nil {
+		response.Error = err.Error()
+		json.NewEncoder(res).Encode(response)
+		return
 
-	if task.Date != "" {
-		date, err = time.Parse(dataFormat, task.Date)
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return err
-		}
-	} else {
-		task.Date = date.Format(dataFormat)
 	}
+	json.NewEncoder(res).Encode(response)
+}
 
-	if date.Before(time.Now()) {
-		if task.Repeat == "" {
-			task.Date = time.Now().Format(dataFormat)
-		} else {
-			task.Date, err = NextDate(time.Now(), task.Date, task.Repeat)
-			if err != nil {
-				response.Error = err.Error()
-				json.NewEncoder(res).Encode(response)
-				return err
-			}
-		}
+func editTask() {
+	res.Header().Set("Content-Type", "application/json; charset=UTF-8")
+	var buf bytes.Buffer
+	task := &Task{}
+	_, err := buf.ReadFrom(req.Body)
+	if err != nil {
+		http.Error(res, err.Error(), http.StatusBadRequest)
+		return
 	}
-	return nil
+
+	err = json.Unmarshal(buf.Bytes(), &task)
+	if err != nil {
+		http.Error(res, err.Error(), http.StatusBadRequest)
+		responseError := struct {
+			Error string `json:"error"`
+		}{Error: err.Error()}
+		json.NewEncoder(res).Encode(responseError)
+		return
+	}
+
+	err = checkInputJSON(res, task)
+	if err != nil {
+		response.Error = err.Error()
+		json.NewEncoder(res).Encode(response)
+		return
+	}
+
+	db, err := sql.Open("sqlite3", DBFile)
+	defer db.Close()
+	query := "UPDATE scheduler SET date = ?, title = ?, comment = ?, repeat = ? WHERE id = ?"
+	_, err = db.Exec(query,
+		task.Date,
+		task.Title,
+		task.Comment,
+		task.Repeat,
+		task.ID)
+
+	if err != nil {
+		fmt.Println(task, err)
+		response.Error = err.Error()
+		json.NewEncoder(res).Encode(response)
+		return
+	}
+	json.NewEncoder(res).Encode(response)
+	return
 }
 
-func taskHandler(res http.ResponseWriter, req *http.Request) {
-	switch req.Method {
-	case http.MethodPost:
-		res.Header().Set("Content-Type", "application/json; charset=UTF-8")
-		var buf bytes.Buffer
-		task := &Task{}
-		_, err := buf.ReadFrom(req.Body)
-		if err != nil {
-			err := errors.New("JSON read error")
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
+func createTask(t *Task) (int64, error) {
+	db, err := sql.Open("sqlite3", DBFile)
+	defer db.Close()
+	query := "INSERT INTO scheduler (date, title, comment, repeat) VALUES (?, ?, ?, ?) RETURNING id"
+	result, err := db.Exec(query, t.Date, t.Title, t.Comment, t.Repeat)
+	if err != nil {
+		return 0, err
+	}
 
-		err = json.Unmarshal(buf.Bytes(), &task)
-		if err != nil {
-			err := errors.New("JSON Unmarshalling error")
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
+	lastId, err := result.LastInsertId()
 
-		err = checkInputJSON(res, task)
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
-		db, err := sql.Open("sqlite3", DBFile)
-		defer db.Close()
-		query := "INSERT INTO scheduler (date, title, comment, repeat) VALUES (?, ?, ?, ?)"
-		result, err := db.Exec(query, task.Date, task.Title, task.Comment, task.Repeat)
+	return , nil
+}
 
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
+func getTaskHandler(w http.ResponseWriter, r *http.Request) {
+	// get input
+	idStr := r.URL.Query().Get("id") // r.FormValue extracts from the request body too, if available, we don't need that
 
-		lastId, err := result.LastInsertId()
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
+	// validate
+	id, err := strconv.Atoi(idStr)
+	if err != nil {
+		if err := sendJson(w, 400, ErrResponse{
+			Error:        true,
+			ErrorMessage: "invalid id",
+		}); err != nil {
+			panic(err)
 		}
-		response := struct {
-			ID int64 `json:"id"`
-		}{ID: lastId}
-		json.NewEncoder(res).Encode(response)
+	}
 
-	case http.MethodGet:
-		id := req.FormValue("id")
-		if id == "" {
-			err := errors.New("Не указан ID задачи")
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
-		db, err := sql.Open("sqlite3", DBFile)
-		defer db.Close()
-		if err != nil {
-			return
-		}
-		query := "SELECT * FROM scheduler WHERE id=?"
-		row, err := db.Query(query, id)
+	// execute
+	task, err := getTask(id)
 
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
-		task := &Task{}
-		defer row.Close()
-		for row.Next() {
-			err := row.Scan(&task.ID, &task.Date, &task.Title, &task.Comment, &task.Repeat)
-			if err != nil {
-				response.Error = err.Error()
-				json.NewEncoder(res).Encode(response)
-				return
-			}
-		}
-		if err = row.Err(); err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
-		data, err := json.Marshal(&task)
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
-		res.WriteHeader(http.StatusOK)
-		_, err = res.Write(data)
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
+	// handle error
+	if err != nil {
+		if err := sendJson(w, 500, ErrResponse{
+			Error:        true,
+			ErrorMessage: "internal server error",
+		}); err != nil {
+			panic(err)
 		}
+	}
 
-	case http.MethodPut:
-		res.Header().Set("Content-Type", "application/json; charset=UTF-8")
-		var buf bytes.Buffer
-		task := &Task{}
-		_, err := buf.ReadFrom(req.Body)
-		if err != nil {
-			http.Error(res, err.Error(), http.StatusBadRequest)
-			return
+	// handle 404
+	if task == nil {
+		if err := sendJson(w, 404, ErrResponse{
+			Error:        true,
+			ErrorMessage: "no task with this id",
+		}); err != nil {
+			panic(err)
 		}
+	}
 
-		err = json.Unmarshal(buf.Bytes(), &task)
-		if err != nil {
-			http.Error(res, err.Error(), http.StatusBadRequest)
-			responseError := struct {
-				Error string `json:"error"`
-			}{Error: err.Error()}
-			json.NewEncoder(res).Encode(responseError)
-			return
-		}
+	// return
+	if err := sendJson(w, 200, task); err != nil {
+		panic(err)
+	}
+}
 
-		err = checkInputJSON(res, task)
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
+func createTaskHandler(w http.ResponseWriter, r *http.Request) {
+	// read data
+	body, err := io.ReadAll(req.Body)
+	if err != nil {
+		panic(err)
+	}
 
-		db, err := sql.Open("sqlite3", DBFile)
-		defer db.Close()
-		query := "UPDATE scheduler SET date = ?, title = ?, comment = ?, repeat = ? WHERE id = ?"
-		_, err = db.Exec(query,
-			task.Date,
-			task.Title,
-			task.Comment,
-			task.Repeat,
-			task.ID)
+	var task *Task
+	err = json.Unmarshal(body, &task)
+	if err != nil {
+		panic(err)
+	}
 
-		if err != nil {
-			fmt.Println(task, err)
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
+	// validate
+	if valid, message := task.IsValid(); !valid {
+		if err := sendJson(w, 400, ErrResponse{
+			Error:        true,
+			ErrorMessage: message,
+		}); err != nil {
+			panic(err) // couldn't even send json, panic
 		}
-		json.NewEncoder(res).Encode(response)
-		return
+	}
 
-	case http.MethodDelete:
-		id := req.FormValue("id")
-		if id == "" {
-			err := errors.New("Не укаазан ID задачи")
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
-		}
+	// execute
+	newTask, err := createTask
+}
 
-		db, err := sql.Open("sqlite3", DBFile)
-		defer db.Close()
-		if err != nil {
-			return
-		}
+func editTaskHandler(w http.ResponseWriter, r *http.Request) {
+	// read
+	// validate
+	// execute
+	// return
+}
+
+func deleteTaskHandler(w http.ResponseWriter, r *http.Request) {
+	// read
+	// validate
+	// execute
+	// return
+}
 
-		query := "DELETE FROM scheduler WHERE id=?"
-		_, err = db.Exec(query, id)
+func taskHandler(w http.ResponseWriter, r *http.Request) {
+	switch r.Method {
+	case http.MethodPost:
+		createTaskHandler(w, r)
 
-		if err != nil {
-			response.Error = err.Error()
-			json.NewEncoder(res).Encode(response)
-			return
+	case http.MethodGet:
+		getTaskHandler(w, r)
+	case http.MethodPut:
+		editTaskHandler(w, r)
 
-		}
-		json.NewEncoder(res).Encode(response)
+	case http.MethodDelete:
+		deleteTaskHandler(w, r)
 	}
 }
 
